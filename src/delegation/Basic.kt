package delegation

import kotlin.reflect.KProperty

/**
 * Covers basics of property delegation & possible use case.
 *
 * @Author cjeon
 * @Since 28/11/2017
 */
class SomeClass(val single: Int) {
    val doubled: Int by DoubleDelegate()
}

class DoubleDelegate {
    /* Returns 👇 value instead of original value */
    operator fun getValue(thisRef: SomeClass, property: KProperty<*>): Int {
        println("DoubleDelegate: getValue called!")
        return thisRef.single * 2
    }

    // single 을 바로 delegate 로 설정하고 항상 설정하는 값과 보이는 값을 다르게 할 수도 있지만
    // Context 를 모르면 이해하기 쉽지 않아서 ex: 1로 설정했는데 읽을 땐 항상 2가 나옴.
    // 특수한 경우 - ex: 자료형이 완전히 다름 - 숫자를 넣으면 Matrix 가 나온다 등 혹은
    // Project member 가 모두 property delegation 에 익숙해지면 사용할 수 있을듯.
}

fun main(args : Array<String>){
    /* Use case of getter delegation */
    val classWithDelegate = SomeClass(1)
    println(classWithDelegate.doubled)

    println("- - - - - - - - - - - -")

    /* Use case of setter delegation */
    val complexState = ComplexState()
    println(complexState.state)
    complexState.state = ComplexState.State.STARTED
    stateSetter(complexState, ComplexState.State.RESUMED)
    Nom().nomStateSetter(complexState, ComplexState.State.DESTROYED)
}

class ComplexState {
    enum class State { CREATED, STARTED, RESUMED, PAUSED, STOPPED, DESTROYED}
    var state : State by StateLogger()

    class StateLogger {
        /* getValue 만 지정하는 건 가능하지만 setValue 만 지정하는 건 불가능함. (왤까요 ? 저도 모릅니다) */
        /* 여기서는 투명하게 값을 전해주기위해 duplicate 를 가지고 있음. */
        /* (그냥 thisRef.state 를 하면 getValue 가 다시 불려서 무한 루프를 탐.) */
        /* (duplicate 없이 투명한 getValue 구현하신 분은 연락바랍니다 ☎️) */
        var state : ComplexState.State = ComplexState.State.CREATED
        operator fun getValue(thisRef: ComplexState, property: KProperty<*>): ComplexState.State {
            return state
        }

        operator fun setValue(thisRef: ComplexState, property: KProperty<*>, value: ComplexState.State) {
            state = value
            val stackTrace = Thread.currentThread().stackTrace
            // 0 = getStackTrace() - 👆
            // 1 = setValue() - this method
            // 2 = setState() - invisible method generated by kotlin
            // 3 = caller of setState() - what we want to know
            println(stackTrace[3].methodName)
        }
    }
}

fun stateSetter(complexState: ComplexState, state : ComplexState.State) {
    complexState.state = state
}

class Nom {
    fun nomStateSetter(complexState: ComplexState, state : ComplexState.State) {
        complexState.state = state
    }
}

/* Additional Info - simple delegation */
class SimpleDelegation() {
    var number = 3
        set(value) = println("setting value of number to $value")
}